# debounce_module.v
``` verilog
`timescale 1ns/100ps
// =====================================================
// debounce_module — 按键消抖（电平稳定化）
// - 二拍同步 + 计数确认
// - 仅输出稳定电平，不产生脉冲
// =====================================================
module debounce_module #(
    parameter integer P_CLK_FREQ      = 50_000_000, // 输入时钟频率 Hz
    parameter integer P_DEBOUNCE_MS   = 10,         // 消抖时间（ms）
    parameter integer P_ACTIVE_LEVEL  = 1           // 有效电平（1=高有效，0=低有效）
)(
    input  wire i_clk,        // 系统时钟
    input  wire i_rst_n,      // 异步复位（低有效）
    input  wire i_key,        // 原始按键信号
    output wire o_key_value   // 消抖后的稳定电平（与 P_ACTIVE_LEVEL 语义一致）
);

    // ------------------------------
    // 计数门限（按 ms 计算，避免中间溢出）
    // ------------------------------
    localparam integer L_CNT_MAX = (P_CLK_FREQ/1000) * P_DEBOUNCE_MS - 1;

    // ------------------------------
    // 输入同步（两拍，抑制亚稳态）
    // ------------------------------
    reg r_key_meta, r_key_sync;
    always @(posedge i_clk or negedge i_rst_n) begin
        if (!i_rst_n) begin
            r_key_meta <= (P_ACTIVE_LEVEL == 1) ? 1'b0 : 1'b1; // 复位到“未按下”的反义电平
            r_key_sync <= (P_ACTIVE_LEVEL == 1) ? 1'b0 : 1'b1;
        end else begin
            r_key_meta <= i_key;
            r_key_sync <= r_key_meta;
        end
    end

    // ------------------------------
    // 跳变检测：电平变化则清零计数
    // ------------------------------
    reg  r_key_sync_d1;
    wire w_edge = (r_key_sync ^ r_key_sync_d1);
    always @(posedge i_clk or negedge i_rst_n) begin
        if (!i_rst_n) r_key_sync_d1 <= (P_ACTIVE_LEVEL == 1) ? 1'b0 : 1'b1;
        else          r_key_sync_d1 <= r_key_sync;
    end

    // ------------------------------
    // 计数确认：保持新电平满 L_CNT_MAX 才更新稳定值
    // ------------------------------
    reg [31:0] r_cnt;
    reg        r_key_stable;

    always @(posedge i_clk or negedge i_rst_n) begin
        if (!i_rst_n) begin
            r_cnt        <= 32'd0;
            r_key_stable <= (P_ACTIVE_LEVEL == 1) ? 1'b0 : 1'b1; // 复位为未按下状态
        end else begin
            if (w_edge) begin
                r_cnt <= 32'd0; // 有跳变，重新计时
            end else if (r_key_sync != r_key_stable) begin
                // 待稳定窗口内持续计时
                if (r_cnt == L_CNT_MAX) begin
                    r_key_stable <= r_key_sync; // 达到门限，更新稳定值
                    r_cnt        <= 32'd0;
                end else begin
                    r_cnt <= r_cnt + 1'b1;
                end
            end else begin
                r_cnt <= 32'd0; // 已稳定，无需计数
            end
        end
    end

    // ------------------------------
    // 输出语义与 P_ACTIVE_LEVEL 保持一致
    // ------------------------------
    assign o_key_value = (P_ACTIVE_LEVEL == 1) ? r_key_stable : ~r_key_stable;

endmodule

```

# tb.sv
``` verilog
`timescale 1ns/1ps

module tb;

  // ================= 参数与时基 =================
  localparam integer P_CLK_FREQ     = 50_000_000; // 50 MHz
  localparam integer P_DEBOUNCE_MS  = 1;         // 消抖 10 ms
  localparam integer P_ACTIVE_LEVEL = 1;          // 有效电平（1=高有效）

  localparam integer L_CLK_PERIOD_NS = 20;        // 50 MHz -> 20 ns
  localparam integer L_MS            = 1_000_000; // 1 ms = 1,000,000 ns

  // ================= 端口信号 =================
  reg  i_clk;
  reg  i_rst_n;
  reg  i_key;
  wire o_key_value;

  // ================= DUT 实例 =================
  debounce_module #(
    .P_CLK_FREQ     (P_CLK_FREQ),
    .P_DEBOUNCE_MS  (P_DEBOUNCE_MS),
    .P_ACTIVE_LEVEL (P_ACTIVE_LEVEL)
  ) u_dut (
    .i_clk      (i_clk),
    .i_rst_n    (i_rst_n),
    .i_key      (i_key),
    .o_key_value(o_key_value)
  );

  // ================= 时钟 =================
  initial i_clk = 1'b0;
  always #(L_CLK_PERIOD_NS/2) i_clk = ~i_clk;

  // ================= 复位：异步断言/同步释放 =================
  task automatic t_reset;
  begin
    i_rst_n = 1'b0;            // 异步断言
    repeat (8) @(posedge i_clk);
    @(posedge i_clk);          // 在时钟上升沿同步释放
    i_rst_n = 1'b1;
    @(posedge i_clk);
  end
  endtask

  // ================= 带抖动的按下/松开 =================
  task automatic t_press_with_bounce;
    integer k;
  begin
    // 约 2 ms 的抖动（快速翻转）
    for (k = 0; k < 10; k = k + 1) begin
      i_key = ~i_key;
      #(200_000); // 0.2 ms
    end
    // 稳定为按下态并保持 > 消抖门限
    i_key = P_ACTIVE_LEVEL;
    #(12 * L_MS); // 12 ms
  end
  endtask

  task automatic t_release_with_bounce;
    integer k;
  begin
    for (k = 0; k < 8; k = k + 1) begin
      i_key = ~i_key;
      #(150_000); // 0.15 ms
    end
    // 稳定为松开态并保持 > 消抖门限
    i_key = ~P_ACTIVE_LEVEL;
    #(12 * L_MS); // 12 ms
  end
  endtask

  // ================= 激励流程 =================
  initial begin
    // 初值
    i_clk   = 1'b0;
    i_key   = ~P_ACTIVE_LEVEL; // 初始“未按下”
    i_rst_n = 1'b1;            // 避免 X 向外扩散

    // 复位
    t_reset();

    // 空闲观察
    #(2 * L_MS);

    // 按下（带抖动）
    $display("[%0t] PRESS with bounce", $time);
    t_press_with_bounce();

    #(5 * L_MS);

    // 松开（带抖动）
    $display("[%0t] RELEASE with bounce", $time);
    t_release_with_bounce();

    #(5 * L_MS);
    $display("[%0t] Done.", $time);
    $stop;
  end



endmodule


```