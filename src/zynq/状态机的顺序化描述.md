
# 🧩 状态机顺序化描述 —— 串口与 AXI4 协议流程建模
> [状态机](https://blog.csdn.net/qq_26074053/article/details/149335857)是一种行为建模方式。我们可以将一个状态机拆解为若干条顺序化描述路径：每条路径聚焦一条关键任务的行为流程，抛弃无关跳转，使逻辑更线性、清晰、可读。本文将以 串口协议 和 AXI4-Full 协议 为例，展示其顺序化描述方式。

# [🔌串口](https://blog.csdn.net/qq_26074053/article/details/149358395)
### 🟦 串口发送流程（TX）
```markdown
wait (tx_start);          // 🟢 等待发送开始信号（如用户请求或发送缓存非空）
load tx_buf;              // 💾 加载要发送的 8 位数据到发送缓冲区（如 r_tx_buf <= i_tx_data）
tx_busy <= 1;             // 🚧 设置发送忙标志，防止重复触发

send start bit;           // 🔰 发送起始位（UART规定为低电平 0）
wait (bit_time);          // ⏳ 起始位持续一个比特周期

repeat (8 bits):          // 🔁 逐位发送数据（从最低位到最高位）
  shift_out_bit;          // ⏺ 输出当前最低位到 tx 引脚（如 txd <= tx_buf[0]）
  wait (bit_time);        // ⏳ 等待一个比特周期，再发送下一位

send stop bit;            // 🟨 发送停止位（UART规定为高电平 1）
tx_busy <= 0;             // ✅ 发送结束，清除忙标志，准备下一次传输
```

### 🟩 串口接收流程（RX）

```markdown
wait (rx_falling_edge);  // ⏬ 检测起始位下降沿
rx_done <= 0;            //🧼清除上次完成标志
wait (half_bit_time);   // 🕓 中心对齐采样
repeat (8 bits):      // 🔁 逐位接收数据（从最低位到最高位）
  sample_bit;     // ⏺ 从 rx 引脚采样当前位的电平（0或1）
  store_to_rx_buf; // 💾 将采样到的这 1bit 存入接收缓冲区的对应位
  wait (bit_time);  // ⏳ 等待一个完整的 bit 时间，再采样下一位
check stop bit;      // ✅ 检查停止位是否为高电平（1），用于校验帧结束是否正确
rx_done <= 1;          // ✅ 完成接收
```

# 🫀 [AXI4-Full](https://blog.csdn.net/qq_26074053/article/details/149357754)

## ✅ 写事务（Write Transaction）

### 📤 Master（主设备）顺序流程：
```verilog
// ==============================================
// AXI 写事务 - 主机发起方
// ==============================================

// 1️⃣ 准备写地址通道
// 设置要写入的地址和控制信息
m_axi_awaddr  <= write_addr;     // 写地址
m_axi_awlen   <= burst_len;      // 突发长度（如1表示单次写）
m_axi_awsize  <= 3'b010;         // 每次传输 4 字节 (2^2 = 4)
m_axi_awburst <= 2'b01;          // INCR模式（地址递增）
m_axi_awvalid <= 1;              // 地址有效
wait (m_axi_awready);           // 🔁 等待从机握手响应
m_axi_awvalid <= 0;              // 地址发送完毕

// 2️⃣ 准备写数据通道
// 设置写入数据，可能为突发数据（此处只写一次）
m_axi_wdata   <= write_data;
m_axi_wstrb   <= 4'b1111;        // 写掩码（4字节全写）
m_axi_wlast   <= 1;              // 最后一拍数据（单次写）
m_axi_wvalid  <= 1;
wait (m_axi_wready);           // 🔁 等待从机准备接收数据
m_axi_wvalid  <= 0;

// 3️⃣ 等待写响应通道
// 设置 bready 表示主机准备接收响应
m_axi_bready  <= 1;
wait (m_axi_bvalid);           // 🔁 等待从机发来响应
read_bresp    = m_axi_bresp;    // 读取响应结果
m_axi_bready  <= 0;

// 写事务完成，主机可设置 done <= 1

```

### 📥 Slave（从设备）顺序流程：
```verilog
// ==============================================
// AXI 写事务 - 从机响应方
// ==============================================
// 1️⃣ 等待地址有效
wait (s_axi_awvalid);             // 🔁 等待主机发来地址
s_axi_awready <= 1;               // 从机准备好接收地址
read_awaddr   = s_axi_awaddr;     // 记录地址
s_axi_awready <= 0;

// 2️⃣ 等待写数据
wait (s_axi_wvalid);              // 🔁 等待主机发来数据
s_axi_wready  <= 1;
write_mem[s_axi_awaddr] <= s_axi_wdata; // 写入内部存储
s_axi_wready  <= 0;

// 3️⃣ 发送写响应
s_axi_bresp   <= 2'b00;           // OKAY响应
s_axi_bvalid  <= 1;
wait (s_axi_bready);              // 🔁 等待主机读取响应
s_axi_bvalid  <= 0;

```

## ✅ 读事务（Read Transaction）

### 📤 Master（主设备）顺序流程：
```verilog
// ==============================================
// AXI 读事务 - 主机发起方
// ==============================================

// 1️⃣ 准备读地址通道
m_axi_araddr  <= read_addr;
m_axi_arlen   <= burst_len;
m_axi_arsize  <= 3'b010;         // 4 字节
m_axi_arburst <= 2'b01;
m_axi_arvalid <= 1;
wait (m_axi_arready);           // 🔁 等待从机握手
m_axi_arvalid <= 0;

// 2️⃣ 接收数据通道
m_axi_rready  <= 1;
wait (m_axi_rvalid);            // 🔁 等待从机送数据
read_data     = m_axi_rdata;
read_rresp    = m_axi_rresp;
m_axi_rready  <= 0;


```

### 📥 Slave（从设备）顺序流程：
```verilog
// ==============================================
// AXI 读事务 - 从机响应方
// ==============================================

// 1️⃣ 等待地址有效
wait (s_axi_arvalid);             // 🔁 等待主机发来地址
s_axi_arready <= 1;
read_araddr   = s_axi_araddr;     // 记录地址
s_axi_arready <= 0;

// 2️⃣ 准备并发送读数据
s_axi_rdata   <= read_mem[s_axi_araddr]; // 从内部读取数据
s_axi_rresp   <= 2'b00;                  // OKAY
s_axi_rlast   <= 1;                      // 末尾标志
s_axi_rvalid  <= 1;
wait (s_axi_rready);              // 🔁 等待主机读取
s_axi_rvalid  <= 0;

```
## 🧠 总结
| 点             | 写事务                   | 读事务              |
| ------------- | --------------------- | ---------------- |
| 发起方向          | 主机 ➜ 从机               | 主机 ➜ 从机          |
| 数据方向          | 主机 ➜ 从机               | 从机 ➜ 主机          |
| 响应信号          | `BRESP`    （写响应通道）           | `RRESP`（读数据通道）  |
| ready/valid配合 | `AW`, `W`, `B` 通道三段握手 | `AR`, `R` 通道两段握手 |
| 是否突发支持        | ✅ 支持突发（可调节 `len`）     | ✅ 支持突发           |
