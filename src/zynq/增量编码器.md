
# encoder_module.v
```verilog
`timescale 1ns/1ps
// =====================================================
// encoder_module.v — 增量式编码器计数模块
// - 输入：A/B 两相信号
// - 输出：16bit 编码器计数值
// - 特点：双触发器同步，检测相位差判断方向并计数
// =====================================================
module encoder_module #(
    parameter integer P_CNT_WIDTH = 16  // 计数器位宽
)(
    input  wire                   i_clk,              // 时钟
    input  wire                   i_rst_n,            // 异步复位，低有效
    input  wire                   i_encoder_a,        // 编码器 A 相
    input  wire                   i_encoder_b,        // 编码器 B 相
    output wire [P_CNT_WIDTH-1:0] o_encoder_value     // 编码器计数值
);

    // =========================
    // 内部寄存器/线网
    // =========================
    reg  [P_CNT_WIDTH-1:0] r_encoder_value;   // 编码器计数寄存器
    reg  [1:0]             r_old_code;        // 上一次状态
    reg  [1:0]             r_sync_code1;      // 一级同步
    reg  [1:0]             r_sync_code2;      // 二级同步

    // =========================
    // 输入同步（防止亚稳态）
    // =========================
    always @(posedge i_clk or negedge i_rst_n) begin
        if (!i_rst_n) begin
            r_sync_code1 <= 2'b00;
            r_sync_code2 <= 2'b00;
        end else begin
            r_sync_code1 <= {i_encoder_b, i_encoder_a}; // A=低位，B=高位
            r_sync_code2 <= r_sync_code1;
        end
    end

    // =========================
    // 编码器计数逻辑（相位差90°判断方向）
    // =========================
    always @(posedge i_clk or negedge i_rst_n) begin
        if (!i_rst_n) begin
            r_old_code      <= 2'b00;
            r_encoder_value <= {P_CNT_WIDTH{1'b0}};
        end else if (r_sync_code2 != r_old_code) begin
            r_old_code <= r_sync_code2;
            case (r_sync_code2)
                2'b00: begin
                    if (r_old_code == 2'b10) r_encoder_value <= r_encoder_value + 1'b1;
                    else if (r_old_code == 2'b01) r_encoder_value <= r_encoder_value - 1'b1;
                end
                2'b01: begin
                    if (r_old_code == 2'b00) r_encoder_value <= r_encoder_value + 1'b1;
                    else if (r_old_code == 2'b11) r_encoder_value <= r_encoder_value - 1'b1;
                end
                2'b11: begin
                    if (r_old_code == 2'b01) r_encoder_value <= r_encoder_value + 1'b1;
                    else if (r_old_code == 2'b10) r_encoder_value <= r_encoder_value - 1'b1;
                end
                2'b10: begin
                    if (r_old_code == 2'b11) r_encoder_value <= r_encoder_value + 1'b1;
                    else if (r_old_code == 2'b00) r_encoder_value <= r_encoder_value - 1'b1;
                end
                default: r_encoder_value <= r_encoder_value;
            endcase
        end
    end

    // =========================
    // 输出
    // =========================
    assign o_encoder_value = r_encoder_value;

endmodule


```

# tb.sv
``` verilog
`timescale 1ns/1ps
// =====================================================
// tb_encoder_module.v — encoder_module testbench
// - 50MHz clock
// - generate forward/backward pulse sequence
// - check encoder counter
// =====================================================
module tb;

    // =========================
    // Parameters & clock period
    // =========================
    localparam integer P_CLK_FREQ   = 50_000_000;  // 50MHz
    localparam real    P_CLK_PERIOD = 1e9 / P_CLK_FREQ; // ns

    // =========================
    // DUT ports
    // =========================
    reg                 r_clk;
    reg                 r_rst_n;
    reg                 r_encoder_a;
    reg                 r_encoder_b;
    wire [15:0]         w_encoder_value;

    // =========================
    // DUT instance
    // =========================
    encoder_module #(
        .P_CNT_WIDTH(16)
    ) u_encoder_module (
        .i_clk          (r_clk),
        .i_rst_n        (r_rst_n),
        .i_encoder_a    (r_encoder_a),
        .i_encoder_b    (r_encoder_b),
        .o_encoder_value(w_encoder_value)
    );

    // =========================
    // Clock generator
    // =========================
    initial begin
        r_clk = 1'b0;
        forever #(P_CLK_PERIOD/2) r_clk = ~r_clk;
    end

    // =========================
    // Task: forward rotation
    // =========================
    task encoder_forward(input integer steps);
        integer i;
        begin
            for (i = 0; i < steps; i = i + 1) begin
                // sequence: 00 -> 01 -> 11 -> 10 -> 00
                {r_encoder_b, r_encoder_a} = 2'b00; #(20);
                {r_encoder_b, r_encoder_a} = 2'b01; #(20);
                {r_encoder_b, r_encoder_a} = 2'b11; #(20);
                {r_encoder_b, r_encoder_a} = 2'b10; #(20);
            end
        end
    endtask

    // =========================
    // Task: backward rotation
    // =========================
    task encoder_backward(input integer steps);
        integer i;
        begin
            for (i = 0; i < steps; i = i + 1) begin
                // sequence: 00 -> 10 -> 11 -> 01 -> 00
                {r_encoder_b, r_encoder_a} = 2'b00; #(20);
                {r_encoder_b, r_encoder_a} = 2'b10; #(20);
                {r_encoder_b, r_encoder_a} = 2'b11; #(20);
                {r_encoder_b, r_encoder_a} = 2'b01; #(20);
            end
        end
    endtask

    // =========================
    // Test sequence
    // =========================
    initial begin
        // init
        r_rst_n     = 1'b0;
        r_encoder_a = 1'b0;
        r_encoder_b = 1'b0;
        #(200);
        r_rst_n     = 1'b1;

        // forward 10 steps
        $display(">>> Forward 10 steps");
        encoder_forward(10);
        #(200);
        $display("Encoder value = %d", w_encoder_value);

        // backward 5 steps
        $display(">>> Backward 5 steps");
        encoder_backward(5);
        #(200);
        $display("Encoder value = %d", w_encoder_value);

        // forward 3 steps
        $display(">>> Forward 3 steps");
        encoder_forward(3);
        #(200);
        $display("Encoder value = %d", w_encoder_value);

        #(200);
        $stop;
    end

endmodule


```