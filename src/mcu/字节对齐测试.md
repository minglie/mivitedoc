# 字节对齐测试
```c
#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/timer.h"
#include "./tfc/collection/fifo.h"
#include "./tfc/msg/Ndata.h"

Nfifo  g_nfifo= Nfifo(80);
// 定时器回调（中断上下文）
bool timer_cb(repeating_timer_t *t) {
    static int sec = 0;
    Ndata nData(20);
    nData.SetWord(++sec);
    size_t ret= g_nfifo.PushBuffer(nData.Buffer());
    if (ret == 0) {
        printf("g_nfifo.PushBuffer() failed\n");
    }
    return true;
}

void test_aligned_uint16_access(uint8_t *buf, uint32_t buf_len) {
    if (buf_len < 8) {
        printf("[测试1] 数组长度不足，跳过测试\n");
        return;
    }

    printf("[测试1] 对齐地址（0偏移）强转：\n");
    uint16_t *align_ptr = (uint16_t *)buf;
    // 读取前4个16位值（对齐偏移：0、2、4、6）
    printf("test_buf[0-1] → uint16_t: 0x%04X\n", align_ptr[0]);  // 预期 0x1234
    printf("test_buf[2-3] → uint16_t: 0x%04X\n", align_ptr[1]);  // 预期 0x5678
    printf("test_buf[4-5] → uint16_t: 0x%04X\n", align_ptr[2]);  // 预期 0xABCD
    printf("test_buf[6-7] → uint16_t: 0x%04X\n\n", align_ptr[3]);  // 预期 0xEF01
}

/**
 * @brief 非对齐地址强转 uint16_t* 取值测试
 */
void test_unaligned_uint16_access() {
    //对齐测试
    //构造测试字节数组（填充已知数据）
    // 数组内容：[0x34, 0x12, 0x78, 0x56, 0xCD, 0xAB, 0x01, 0xEF]
    // 小端模式下，对齐的16位值应为：0x1234、0x5678、0xABCD、0xEF01
    uint8_t test_buf[8] = {0x34, 0x12, 0x78, 0x56, 0xCD, 0xAB, 0x01, 0xEF};
    // ==================== 测试1：对齐地址强转 uint16_t* 取值（正常） ====================
    printf("[测试1] 对齐地址（0偏移）强转：\n");
    // 地址对齐：test_buf 起始地址是 2/4 字节对齐（编译器自动优化）
    uint16_t *align_ptr = (uint16_t *)test_buf;
    // 读取前4个16位值（仅对齐偏移：0、2、4、6）
    printf("test_buf[0-1] → uint16_t: 0x%04X\n", align_ptr[0]);  // 预期 0x1234
    printf("test_buf[2-3] → uint16_t: 0x%04X\n", align_ptr[1]);  // 预期 0x5678
    printf("test_buf[4-5] → uint16_t: 0x%04X\n", align_ptr[2]);  // 预期 0xABCD
    printf("test_buf[6-7] → uint16_t: 0x%04X\n\n", align_ptr[3]);  // 预期 0xEF01
    // ==================== 测试2：非对齐地址强转 uint16_t* 取值（触发HardFault） ====================
    printf("[测试2] 非对齐地址（1偏移）强转：\n");
    printf("即将访问 test_buf[1] 起始的16位数据...\n");
    // 地址非对齐：test_buf+1 最后1位是1，违反M0+ 16位对齐要求
    uint16_t *unalign_ptr = (uint16_t *)(test_buf + 1);
    uint16_t val = unalign_ptr[0]; // 执行此行立即触发HardFault
    printf("读取值：0x%04X\n", val); // 不会执行到这里
}





int main() {
    stdio_init_all();

    static repeating_timer_t timer;
    add_repeating_timer_ms(
            1000,        // 1s
            timer_cb,
            NULL,
            &timer
    );
    test_unaligned_uint16_access();
    while (true) {
        int v;
        uint8_t buf[80];
        size_t ret=  g_nfifo.PopBuffer(buf, sizeof(buf));
        if (ret > 0) {
            Ndata nData(20);
            nData.Import( buf);
            v = nData.GetWord();
            printf("v=%d , %d\n", v,nData.Length());
        }
        sleep_ms(1000);
        // 主循环干别的事
        tight_loop_contents();
    }
}

```